/**
 * Code Steganography Module
 * 
 * This module implements a technique to hide messages within code comments
 * using various encoding techniques to make the hidden data blend in with
 * normal comments.
 */

/**
 * Convert text to binary
 */
function textToBinary(text: string): string {
  return Array.from(text)
    .map(char => char.charCodeAt(0).toString(2).padStart(8, '0'))
    .join('');
}

/**
 * Convert binary to text
 */
function binaryToText(binary: string): string {
  const chunks = binary.match(/.{1,8}/g) || [];
  return chunks.map(chunk => {
    return String.fromCharCode(parseInt(chunk, 2));
  }).join('');
}

/**
 * Encrypt a message with a more reliable method
 */
function encryptMessage(message: string, password: string): string {
  if (!password) return message;
  
  // Create a repeating key from the password
  let key = '';
  while (key.length < message.length) {
    key += password;
  }
  key = key.slice(0, message.length);
  
  // Simple character shifting encryption
  let encrypted = '';
  for (let i = 0; i < message.length; i++) {
    const messageChar = message.charCodeAt(i);
    const keyChar = key.charCodeAt(i % key.length);
    // Convert to a number 0-255, shift, and wrap around
    const encryptedChar = (messageChar + keyChar) % 256;
    encrypted += String.fromCharCode(encryptedChar);
  }
  
  return encrypted;
}

/**
 * Decrypt a message with a more reliable method
 */
function decryptMessage(encrypted: string, password: string): string {
  if (!password) return encrypted;
  
  // Create a repeating key from the password
  let key = '';
  while (key.length < encrypted.length) {
    key += password;
  }
  key = key.slice(0, encrypted.length);
  
  // Simple character shifting decryption
  let decrypted = '';
  for (let i = 0; i < encrypted.length; i++) {
    const encryptedChar = encrypted.charCodeAt(i);
    const keyChar = key.charCodeAt(i % key.length);
    // Reverse the shift and handle wrap around
    let decryptedChar = (encryptedChar - keyChar) % 256;
    if (decryptedChar < 0) decryptedChar += 256;
    decrypted += String.fromCharCode(decryptedChar);
  }
  
  return decrypted;
}

// Characters for our encoding - each set has 64 characters (6 bits)
const BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const UUID_LIKE_CHARS = '0123456789abcdef';
const HASH_LIKE_CHARS = '0123456789abcdef';

// Collection of believable comment patterns
const COMMENT_TEMPLATES = [
  // License header template
  {
    before: '/**\n * @license\n * Copyright (c) ',
    after: '\n * Licensed under the MIT License.\n */',
    encoder: (encoded: string) => {
      // Format as a year range: 2023-2024 Organization, Inc.
      const year = new Date().getFullYear();
      return `${year}-${year + 1} ${encoded.slice(0, 8)}, Inc.`;
    }
  },
  // Generated file header
  {
    before: '/**\n * GENERATED FILE - DO NOT MODIFY\n * Generated by build system on: ',
    after: '\n */',
    encoder: (encoded: string) => {
      // Format as an ISO date and hash: 2024-02-26T14:32:41Z [86ef12b4]
      const now = new Date().toISOString().slice(0, 19) + 'Z';
      // Use part of the encoded data as a believable hash
      const hash = encoded.replace(/[^0-9a-f]/g, '').slice(0, 8);
      return `${now} [${hash}]`;
    }
  },
  // Package info comment
  {
    before: '/**\n * Package info:\n * package-name: my-package\n * version: ',
    after: '\n */',
    encoder: (encoded: string) => {
      // Format as semver with hash suffix: 2.3.0-3f8eb2a
      const minor = Math.floor(Math.random() * 10);
      const patch = Math.floor(Math.random() * 20);
      const hash = encoded.replace(/[^0-9a-f]/g, '').slice(0, 7);
      return `2.${minor}.${patch}-${hash}`;
    }
  },
  // API documentation comment
  {
    before: '/**\n * @api {post} /api/v1/auth/login Login\n * @apiVersion ',
    after: '\n * @apiName Login\n * @apiGroup Authentication\n */',
    encoder: (encoded: string) => {
      // Format as a version number: 1.2.3
      // Use first 5 chars of encoded data to create a believable version
      const versionChars = encoded.replace(/[^0-9.]/g, '').slice(0, 5);
      const major = versionChars[0] || '1';
      const minor = versionChars[1] || '0';
      const patch = versionChars[2] || '0';
      return `${major}.${minor}.${patch}`;
    }
  },
  // TODO comment with JIRA-like ticket
  {
    before: '// TODO: ',
    after: '',
    encoder: (encoded: string) => {
      // Format as a JIRA ticket reference: [PROJ-123] Fix edge case bug
      const ticketNum = encoded.replace(/[^0-9]/g, '').slice(0, 3).padStart(3, '1');
      const remainderLetters = encoded.replace(/[^a-zA-Z ]/g, '').slice(0, 20);
      return `[PROJ-${ticketNum}] ${remainderLetters || 'Refactor this part of the code'}`;
    }
  },
  // Git commit-like comment
  {
    before: '/* commit: ',
    after: ' */',
    encoder: (encoded: string) => {
      // Format as a git commit hash: 3f8a6b2c9d0e1f4a5b6c7d8e9f0a1b2c
      return encoded.replace(/[^0-9a-f]/g, '').slice(0, 32).padEnd(32, '0');
    }
  }
];

// Minimum entropy required in a comment to consider it may contain a secret
const MIN_ENTROPY_BITS = 20;

/**
 * Calculate Shannon entropy of a string
 * Higher entropy means more random (potentially encoded) data
 */
function calculateEntropy(str: string): number {
  const len = str.length;
  const frequencies: Record<string, number> = {};
  
  // Count character frequencies
  for (let i = 0; i < len; i++) {
    const char = str[i];
    frequencies[char] = (frequencies[char] || 0) + 1;
  }
  
  // Calculate entropy
  return Object.values(frequencies).reduce((entropy, freq) => {
    const p = freq / len;
    return entropy - p * Math.log2(p);
  }, 0);
}

/**
 * Encode a binary string to a Base64-like representation
 */
function encodeToBase64(binary: string): string {
  // Pad binary to multiple of 6
  const padded = binary.padEnd(Math.ceil(binary.length / 6) * 6, '0');
  const chunks = padded.match(/.{1,6}/g) || [];
  
  return chunks.map(chunk => {
    const value = parseInt(chunk, 2);
    return BASE64_CHARS[value];
  }).join('');
}

/**
 * Decode from Base64-like representation to binary
 */
function decodeFromBase64(encoded: string): string {
  let binary = '';
  
  for (let i = 0; i < encoded.length; i++) {
    const char = encoded[i];
    const value = BASE64_CHARS.indexOf(char);
    if (value === -1) continue; // Skip invalid characters
    
    binary += value.toString(2).padStart(6, '0');
  }
  
  return binary;
}

/**
 * Find all comments in the code
 */
function findComments(code: string): { type: string, start: number, end: number, content: string }[] {
  const comments = [];
  let inSingleLineComment = false;
  let inMultiLineComment = false;
  let inString = false;
  let stringChar = '';
  let start = 0;
  
  for (let i = 0; i < code.length; i++) {
    const char = code[i];
    const nextChar = code[i+1] || '';
    
    // Handle strings (to avoid finding comments in string literals)
    if (!inSingleLineComment && !inMultiLineComment) {
      if (!inString && (char === '"' || char === "'" || char === '`')) {
        inString = true;
        stringChar = char;
        continue;
      } else if (inString && char === stringChar && code[i-1] !== '\\') {
        inString = false;
        continue;
      }
    }
    
    if (inString) continue;
    
    // Detect start of comments
    if (!inSingleLineComment && !inMultiLineComment) {
      if (char === '/' && nextChar === '/') {
        inSingleLineComment = true;
        start = i;
        i++; // Skip the next slash
        continue;
      } else if (char === '/' && nextChar === '*') {
        inMultiLineComment = true;
        start = i;
        i++; // Skip the next asterisk
        continue;
      }
    }
    
    // Detect end of comments
    if (inSingleLineComment && (char === '\n' || i === code.length - 1)) {
      inSingleLineComment = false;
      const end = i === code.length - 1 ? i + 1 : i;
      comments.push({
        type: 'single',
        start,
        end,
        content: code.substring(start, end)
      });
    } else if (inMultiLineComment && char === '*' && nextChar === '/') {
      inMultiLineComment = false;
      const end = i + 2;
      comments.push({
        type: 'multi',
        start,
        end,
        content: code.substring(start, end)
      });
      i++; // Skip the closing slash
    }
  }
  
  return comments;
}

/**
 * Detect the language of the source code
 */
export function detectLanguage(sourceCode: string): string {
  // Simplified language detection based on file patterns and keywords
  const normalizedCode = sourceCode.toLowerCase();
  
  // HTML detection
  if (normalizedCode.includes('<!doctype html>') || 
      normalizedCode.includes('<html') || 
      (normalizedCode.includes('<body') && normalizedCode.includes('<head'))) {
    return 'html';
  }
  
  // CSS detection
  if ((normalizedCode.includes('{') && normalizedCode.includes('}')) &&
      (normalizedCode.includes('margin:') || normalizedCode.includes('padding:') ||
       normalizedCode.includes('color:') || normalizedCode.includes('@media'))) {
    return 'css';
  }
  
  // Python detection
  if (normalizedCode.includes('def ') && 
      (normalizedCode.includes('import ') || normalizedCode.includes('class ')) &&
      (normalizedCode.includes(':') || normalizedCode.includes('    '))) {
    return 'python';
  }
  
  // TypeScript/JavaScript detection
  if (normalizedCode.includes('function') || 
      normalizedCode.includes('=>') || 
      normalizedCode.includes('const ') ||
      normalizedCode.includes('let ') ||
      normalizedCode.includes('interface ') ||
      normalizedCode.includes('class ')) {
    // Check if it's TypeScript specifically
    if (normalizedCode.includes(':') && 
        (normalizedCode.includes('interface ') || normalizedCode.includes(': string') ||
         normalizedCode.includes(': number') || normalizedCode.includes(': boolean'))) {
      return 'typescript';
    }
    return 'javascript';
  }
  
  // Default to javascript if we can't detect
  return 'javascript';
}

/**
 * Get language-specific comment markers
 */
function getCommentMarkersForLanguage(lang: string): { 
  lineComment: string; 
  blockCommentStart: string; 
  blockCommentEnd: string;
  canUseHTML: boolean;
} {
  switch (lang) {
    case 'html':
      return { 
        lineComment: '<!-- ', 
        blockCommentStart: '<!-- ', 
        blockCommentEnd: ' -->',
        canUseHTML: true
      };
    case 'css':
      return { 
        lineComment: '/* ', 
        blockCommentStart: '/* ', 
        blockCommentEnd: ' */',
        canUseHTML: false
      };
    case 'python':
      return { 
        lineComment: '# ', 
        blockCommentStart: '"""\n', 
        blockCommentEnd: '\n"""',
        canUseHTML: false
      };
    case 'typescript':
    case 'javascript':
    default:
      return { 
        lineComment: '// ', 
        blockCommentStart: '/* ', 
        blockCommentEnd: ' */',
        canUseHTML: false
      };
  }
}

/**
 * Select the best comment template based on the message length and language
 */
function selectCommentTemplate(binaryLength: number, lang: string): typeof COMMENT_TEMPLATES[0] {
  const { lineComment, blockCommentStart, blockCommentEnd, canUseHTML } = getCommentMarkersForLanguage(lang);
  
  // Create language-specific comment templates
  let languageTemplates = [...COMMENT_TEMPLATES];
  
  // Customize templates based on language
  if (lang === 'html') {
    // For HTML, we need to be careful with comments as they'll be visible in the rendered page
    // Use a hidden meta tag or a conditional comment approach
    languageTemplates = [
      {
        before: '<meta name="generator" content="',
        after: '">',
        encoder: (encoded: string) => {
          return `CodeCloak v${encoded.slice(0, 5)}`;
        }
      },
      {
        before: '<!-- version: ',
        after: ' -->',
        encoder: (encoded: string) => {
          return encoded.replace(/[^0-9a-f]/g, '').slice(0, 32);
        }
      },
      {
        before: '<script type="application/ld+json">{"@context":"https://schema.org","@type":"WebPage","version":"',
        after: '"}</script>',
        encoder: (encoded: string) => {
          return encoded.replace(/[^0-9a-zA-Z]/g, '').slice(0, 20);
        }
      }
    ];
  } else if (lang === 'python') {
    // For Python, use Python-style docstrings and comments
    languageTemplates = [
      {
        before: '# TODO: ',
        after: '',
        encoder: (encoded: string) => {
          const ticketNum = encoded.replace(/[^0-9]/g, '').slice(0, 3).padStart(3, '1');
          const remainderLetters = encoded.replace(/[^a-zA-Z ]/g, '').slice(0, 20);
          return `[PY-${ticketNum}] ${remainderLetters || 'Refactor this function'}`;
        }
      },
      {
        before: '"""\n',
        after: '\n"""',
        encoder: (encoded: string) => {
          return `Generated by build system\nVersion: ${encoded.replace(/[^0-9a-f]/g, '').slice(0, 16)}`;
        }
      }
    ];
  }
  
  // Select a template with enough capacity for our message
  // Choose randomly among suitable templates
  const suitable = languageTemplates.filter((_, index) => {
    // For simplicity, we're just using the index to determine capacity
    // Real implementation would calculate actual capacity
    return binaryLength <= (index + 1) * 50; // Arbitrary capacity calculation
  });
  
  if (suitable.length === 0) {
    // If no suitable template, use the last one (most capacity)
    return languageTemplates[languageTemplates.length - 1];
  }
  
  // Choose randomly among suitable templates
  return suitable[Math.floor(Math.random() * suitable.length)];
}

/**
 * Hide a secret message within source code using believable comments
 */
export function hideInCode(
  sourceCode: string, 
  secret: string, 
  password: string = '',
  encrypt: boolean = true
): string {
  // Process the secret message
  // Add a tag to identify the message
  let processedSecret = secret;
  if (!processedSecret.startsWith('STEG:')) {
    processedSecret = 'STEG:' + processedSecret;
  }
  
  // Encrypt if requested
  if (encrypt && password) {
    processedSecret = encryptMessage(processedSecret, password);
  }
  
  // Convert to binary and then to Base64
  const binarySecret = textToBinary(processedSecret);
  const encodedSecret = encodeToBase64(binarySecret);
  
  // Detect the language of the source code
  const language = detectLanguage(sourceCode);
  console.log(`Detected language: ${language}`);
  
  // Select a comment template based on the message length and language
  const template = selectCommentTemplate(binarySecret.length, language || 'javascript');
  
  // Create the encoded comment
  const hiddenComment = template.before + template.encoder(encodedSecret) + template.after;
  
  // Find existing comments to potentially replace
  const comments = findComments(sourceCode);
  
  // For HTML, we want to insert our hidden data in a specific place
  if (language === 'html') {
    // Try to find the <head> tag to insert our metadata
    const headMatch = sourceCode.match(/<head[^>]*>/i);
    if (headMatch && headMatch.index !== undefined) {
      const insertPoint = headMatch.index + headMatch[0].length;
      return sourceCode.substring(0, insertPoint) + 
             '\n  ' + hiddenComment + '\n' + 
             sourceCode.substring(insertPoint);
    }
    
    // If no <head> tag, try to find <html> tag
    const htmlMatch = sourceCode.match(/<html[^>]*>/i);
    if (htmlMatch && htmlMatch.index !== undefined) {
      const insertPoint = htmlMatch.index + htmlMatch[0].length;
      return sourceCode.substring(0, insertPoint) + 
             '\n  ' + hiddenComment + '\n' + 
             sourceCode.substring(insertPoint);
    }
  }
  
  // For other languages, we can replace existing comments or add a new one
  if (comments.length > 0) {
    // Replace a random existing comment
    const targetComment = comments[Math.floor(Math.random() * comments.length)];
    return sourceCode.substring(0, targetComment.start) + 
           hiddenComment + 
           sourceCode.substring(targetComment.end);
  } else {
    // If no existing comments, insert at the top
    return hiddenComment + '\n\n' + sourceCode;
  }
}

/**
 * Get HTML-specific templates for checking
 */
function getHTMLTemplates(): typeof COMMENT_TEMPLATES {
  return [
    {
      before: '<meta name="generator" content="',
      after: '">',
      encoder: () => ''
    },
    {
      before: '<!-- version: ',
      after: ' -->',
      encoder: () => ''
    },
    {
      before: '<script type="application/ld+json">{"@context":"https://schema.org","@type":"WebPage","version":"',
      after: '"}</script>',
      encoder: () => ''
    }
  ];
}

/**
 * Get Python-specific templates for checking
 */
function getPythonTemplates(): typeof COMMENT_TEMPLATES {
  return [
    {
      before: '# TODO: ',
      after: '',
      encoder: () => ''
    },
    {
      before: '"""\n',
      after: '\n"""',
      encoder: () => ''
    }
  ];
}

/**
 * Try to extract encoded data from a comment using all templates
 */
function tryExtractEncodedData(commentText: string, codeLang: string = 'javascript'): string | null {
  // Get language-specific templates
  let templatesForLanguage = [...COMMENT_TEMPLATES];
  
  if (codeLang === 'html') {
    templatesForLanguage = [...templatesForLanguage, ...getHTMLTemplates()];
  } else if (codeLang === 'python') {
    templatesForLanguage = [...templatesForLanguage, ...getPythonTemplates()];
  }
  
  // Check against all templates
  for (const template of templatesForLanguage) {
    if (commentText.startsWith(template.before) && commentText.endsWith(template.after)) {
      // Extract the middle part
      const middle = commentText.substring(
        template.before.length, 
        commentText.length - template.after.length
      );
      
      // Keep only valid Base64 characters
      return middle.split('').filter(c => BASE64_CHARS.includes(c)).join('');
    }
  }
  
  // Look for high entropy sections in the comment
  // This is a fallback method
  const words = commentText.split(/\s+/);
  for (const word of words) {
    if (word.length >= 8) {
      const entropy = calculateEntropy(word);
      if (entropy * word.length > MIN_ENTROPY_BITS) {
        // This word has high entropy, might be our encoded data
        return word.split('').filter(c => BASE64_CHARS.includes(c)).join('');
      }
    }
  }
  
  return null;
}

/**
 * Reveal a hidden message from source code
 */
export function revealFromCode(
  encodedCode: string,
  password: string = ''
): string {
  // Detect the language
  const language = detectLanguage(encodedCode);
  console.log(`Detected language for revealing: ${language}`);
  
  // For HTML, check for our special HTML tags first
  if (language === 'html') {
    // Check meta tags
    const metaMatch = encodedCode.match(/<meta\s+name="generator"\s+content="CodeCloak v([^"]+)"/i);
    if (metaMatch && metaMatch[1]) {
      try {
        // Extract and process the data
        const encodedData = metaMatch[1];
        const binaryMessage = decodeFromBase64(encodedData);
        let message = binaryToText(binaryMessage.substring(0, Math.floor(binaryMessage.length / 8) * 8));
        
        if (password) {
          message = decryptMessage(message, password);
        }
        
        if (message.length > 0 && /^[\x20-\x7E]+$/.test(message)) {
          return message;
        }
      } catch (e) {
        // If this approach fails, continue to regular comment checking
      }
    }
    
    // Check JSON-LD
    const jsonLdMatch = encodedCode.match(/<script\s+type="application\/ld\+json"[^>]*>{"@context":"https:\/\/schema.org","@type":"WebPage","version":"([^"]+)"}<\/script>/i);
    if (jsonLdMatch && jsonLdMatch[1]) {
      try {
        // Extract and process the data
        const encodedData = jsonLdMatch[1];
        const binaryMessage = decodeFromBase64(encodedData);
        let message = binaryToText(binaryMessage.substring(0, Math.floor(binaryMessage.length / 8) * 8));
        
        if (password) {
          message = decryptMessage(message, password);
        }
        
        if (message.length > 0 && /^[\x20-\x7E]+$/.test(message)) {
          return message;
        }
      } catch (e) {
        // If this approach fails, continue to regular comment checking
      }
    }
  }
  
  // Find all comments in the code
  const comments = findComments(encodedCode);
  
  // If we're in HTML mode but can't find comments, don't error out yet
  if (comments.length === 0 && language !== 'html') {
    throw new Error('No comments found in the code to check for hidden messages.');
  }
  
  // Try to extract encoded data from each comment
  for (const comment of comments) {
    const encodedData = tryExtractEncodedData(comment.content, language);
    
    if (encodedData) {
      try {
        // Decode from Base64 to binary
        const binaryMessage = decodeFromBase64(encodedData);
        
        // Convert binary back to text
        let message = binaryToText(binaryMessage.substring(0, Math.floor(binaryMessage.length / 8) * 8));
        
        // Decrypt if password provided
        if (password) {
          message = decryptMessage(message, password);
        }
        
        // Check if the message makes sense (has printable characters)
        if (message.length > 0 && /^[\x20-\x7E]+$/.test(message)) {
          return message;
        }
      } catch (e) {
        // If decoding fails, continue to the next comment
        continue;
      }
    }
  }
  
  throw new Error('No hidden message found in the code.');
}

/**
 * Check if code might contain a hidden message
 * This is just a heuristic - we look for comments with higher-than-normal entropy
 */
export function mightContainHiddenMessage(code: string): boolean {
  const comments = findComments(code);
  
  for (const comment of comments) {
    // Calculate entropy of the comment content
    const entropy = calculateEntropy(comment.content);
    
    // Check if the entropy is suspiciously high
    // Typical English text has entropy around 4-5 bits per character
    if (entropy > 5.5) {
      return true;
    }
    
    // Also check for our templated comments
    for (const template of COMMENT_TEMPLATES) {
      if (comment.content.startsWith(template.before) && 
          comment.content.endsWith(template.after)) {
        return true;
      }
    }
  }
  
  return false;
}