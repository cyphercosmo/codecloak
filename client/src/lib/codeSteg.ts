/**
 * Code Steganography Module
 * 
 * This module implements a technique to hide messages within code comments
 * using various encoding techniques to make the hidden data blend in with
 * normal comments.
 */

/**
 * Convert text to binary
 */
function textToBinary(text: string): string {
  return Array.from(text)
    .map(char => char.charCodeAt(0).toString(2).padStart(8, '0'))
    .join('');
}

/**
 * Convert binary to text
 */
function binaryToText(binary: string): string {
  const chunks = binary.match(/.{1,8}/g) || [];
  return chunks.map(chunk => {
    return String.fromCharCode(parseInt(chunk, 2));
  }).join('');
}

/**
 * Encrypt a message with a simple XOR cipher
 */
function encryptMessage(message: string, password: string): string {
  if (!password) return message;
  
  let encrypted = '';
  const passwordBinary = textToBinary(password);
  const messageBinary = textToBinary(message);
  
  for (let i = 0; i < messageBinary.length; i++) {
    const messageChar = messageBinary[i];
    const passwordChar = passwordBinary[i % passwordBinary.length];
    // XOR operation
    encrypted += messageChar === passwordChar ? '0' : '1';
  }
  
  return binaryToText(encrypted);
}

/**
 * Decrypt a message with a simple XOR cipher
 */
function decryptMessage(encrypted: string, password: string): string {
  if (!password) return encrypted;
  
  let decrypted = '';
  const passwordBinary = textToBinary(password);
  const encryptedBinary = textToBinary(encrypted);
  
  for (let i = 0; i < encryptedBinary.length; i++) {
    const encryptedChar = encryptedBinary[i];
    const passwordChar = passwordBinary[i % passwordBinary.length];
    // XOR operation
    decrypted += encryptedChar === passwordChar ? '0' : '1';
  }
  
  return binaryToText(decrypted);
}

// Characters for our encoding - each set has 64 characters (6 bits)
const BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const UUID_LIKE_CHARS = '0123456789abcdef';
const HASH_LIKE_CHARS = '0123456789abcdef';

// Collection of believable comment patterns
const COMMENT_TEMPLATES = [
  // License header template
  {
    before: '/**\n * @license\n * Copyright (c) ',
    after: '\n * Licensed under the MIT License.\n */',
    encoder: (encoded: string) => {
      // Format as a year range: 2023-2024 Organization, Inc.
      const year = new Date().getFullYear();
      return `${year}-${year + 1} ${encoded.slice(0, 8)}, Inc.`;
    }
  },
  // Generated file header
  {
    before: '/**\n * GENERATED FILE - DO NOT MODIFY\n * Generated by build system on: ',
    after: '\n */',
    encoder: (encoded: string) => {
      // Format as an ISO date and hash: 2024-02-26T14:32:41Z [86ef12b4]
      const now = new Date().toISOString().slice(0, 19) + 'Z';
      // Use part of the encoded data as a believable hash
      const hash = encoded.replace(/[^0-9a-f]/g, '').slice(0, 8);
      return `${now} [${hash}]`;
    }
  },
  // Package info comment
  {
    before: '/**\n * Package info:\n * package-name: my-package\n * version: ',
    after: '\n */',
    encoder: (encoded: string) => {
      // Format as semver with hash suffix: 2.3.0-3f8eb2a
      const minor = Math.floor(Math.random() * 10);
      const patch = Math.floor(Math.random() * 20);
      const hash = encoded.replace(/[^0-9a-f]/g, '').slice(0, 7);
      return `2.${minor}.${patch}-${hash}`;
    }
  },
  // API documentation comment
  {
    before: '/**\n * @api {post} /api/v1/auth/login Login\n * @apiVersion ',
    after: '\n * @apiName Login\n * @apiGroup Authentication\n */',
    encoder: (encoded: string) => {
      // Format as a version number: 1.2.3
      // Use first 5 chars of encoded data to create a believable version
      const versionChars = encoded.replace(/[^0-9.]/g, '').slice(0, 5);
      const major = versionChars[0] || '1';
      const minor = versionChars[1] || '0';
      const patch = versionChars[2] || '0';
      return `${major}.${minor}.${patch}`;
    }
  },
  // TODO comment with JIRA-like ticket
  {
    before: '// TODO: ',
    after: '',
    encoder: (encoded: string) => {
      // Format as a JIRA ticket reference: [PROJ-123] Fix edge case bug
      const ticketNum = encoded.replace(/[^0-9]/g, '').slice(0, 3).padStart(3, '1');
      const remainderLetters = encoded.replace(/[^a-zA-Z ]/g, '').slice(0, 20);
      return `[PROJ-${ticketNum}] ${remainderLetters || 'Refactor this part of the code'}`;
    }
  },
  // Git commit-like comment
  {
    before: '/* commit: ',
    after: ' */',
    encoder: (encoded: string) => {
      // Format as a git commit hash: 3f8a6b2c9d0e1f4a5b6c7d8e9f0a1b2c
      return encoded.replace(/[^0-9a-f]/g, '').slice(0, 32).padEnd(32, '0');
    }
  }
];

// Minimum entropy required in a comment to consider it may contain a secret
const MIN_ENTROPY_BITS = 20;

/**
 * Calculate Shannon entropy of a string
 * Higher entropy means more random (potentially encoded) data
 */
function calculateEntropy(str: string): number {
  const len = str.length;
  const frequencies: Record<string, number> = {};
  
  // Count character frequencies
  for (let i = 0; i < len; i++) {
    const char = str[i];
    frequencies[char] = (frequencies[char] || 0) + 1;
  }
  
  // Calculate entropy
  return Object.values(frequencies).reduce((entropy, freq) => {
    const p = freq / len;
    return entropy - p * Math.log2(p);
  }, 0);
}

/**
 * Encode a binary string to a Base64-like representation
 */
function encodeToBase64(binary: string): string {
  // Pad binary to multiple of 6
  const padded = binary.padEnd(Math.ceil(binary.length / 6) * 6, '0');
  const chunks = padded.match(/.{1,6}/g) || [];
  
  return chunks.map(chunk => {
    const value = parseInt(chunk, 2);
    return BASE64_CHARS[value];
  }).join('');
}

/**
 * Decode from Base64-like representation to binary
 */
function decodeFromBase64(encoded: string): string {
  let binary = '';
  
  for (let i = 0; i < encoded.length; i++) {
    const char = encoded[i];
    const value = BASE64_CHARS.indexOf(char);
    if (value === -1) continue; // Skip invalid characters
    
    binary += value.toString(2).padStart(6, '0');
  }
  
  return binary;
}

/**
 * Find all comments in the code
 */
function findComments(code: string): { type: string, start: number, end: number, content: string }[] {
  const comments = [];
  let inSingleLineComment = false;
  let inMultiLineComment = false;
  let inString = false;
  let stringChar = '';
  let start = 0;
  
  for (let i = 0; i < code.length; i++) {
    const char = code[i];
    const nextChar = code[i+1] || '';
    
    // Handle strings (to avoid finding comments in string literals)
    if (!inSingleLineComment && !inMultiLineComment) {
      if (!inString && (char === '"' || char === "'" || char === '`')) {
        inString = true;
        stringChar = char;
        continue;
      } else if (inString && char === stringChar && code[i-1] !== '\\') {
        inString = false;
        continue;
      }
    }
    
    if (inString) continue;
    
    // Detect start of comments
    if (!inSingleLineComment && !inMultiLineComment) {
      if (char === '/' && nextChar === '/') {
        inSingleLineComment = true;
        start = i;
        i++; // Skip the next slash
        continue;
      } else if (char === '/' && nextChar === '*') {
        inMultiLineComment = true;
        start = i;
        i++; // Skip the next asterisk
        continue;
      }
    }
    
    // Detect end of comments
    if (inSingleLineComment && (char === '\n' || i === code.length - 1)) {
      inSingleLineComment = false;
      const end = i === code.length - 1 ? i + 1 : i;
      comments.push({
        type: 'single',
        start,
        end,
        content: code.substring(start, end)
      });
    } else if (inMultiLineComment && char === '*' && nextChar === '/') {
      inMultiLineComment = false;
      const end = i + 2;
      comments.push({
        type: 'multi',
        start,
        end,
        content: code.substring(start, end)
      });
      i++; // Skip the closing slash
    }
  }
  
  return comments;
}

/**
 * Select the best comment template based on the message length
 */
function selectCommentTemplate(binaryLength: number): typeof COMMENT_TEMPLATES[0] {
  // Select a template with enough capacity for our message
  // Choose randomly among suitable templates
  const suitable = COMMENT_TEMPLATES.filter((_, index) => {
    // For simplicity, we're just using the index to determine capacity
    // Real implementation would calculate actual capacity
    return binaryLength <= (index + 1) * 50; // Arbitrary capacity calculation
  });
  
  if (suitable.length === 0) {
    // If no suitable template, use the last one (most capacity)
    return COMMENT_TEMPLATES[COMMENT_TEMPLATES.length - 1];
  }
  
  // Choose randomly among suitable templates
  return suitable[Math.floor(Math.random() * suitable.length)];
}

/**
 * Hide a secret message within source code using believable comments
 */
export function hideInCode(
  sourceCode: string, 
  secret: string, 
  password: string = '',
  encrypt: boolean = true
): string {
  // Process the secret message
  let processedSecret = secret;
  if (encrypt && password) {
    processedSecret = encryptMessage(processedSecret, password);
  }
  
  // Convert to binary and then to Base64
  const binarySecret = textToBinary(processedSecret);
  const encodedSecret = encodeToBase64(binarySecret);
  
  // Select a comment template based on the message length
  const template = selectCommentTemplate(binarySecret.length);
  
  // Create the encoded comment
  const hiddenComment = template.before + template.encoder(encodedSecret) + template.after;
  
  // Find existing comments to potentially replace
  const comments = findComments(sourceCode);
  
  if (comments.length > 0) {
    // Replace a random existing comment
    const targetComment = comments[Math.floor(Math.random() * comments.length)];
    return sourceCode.substring(0, targetComment.start) + 
           hiddenComment + 
           sourceCode.substring(targetComment.end);
  } else {
    // If no existing comments, insert at the top
    return hiddenComment + '\n\n' + sourceCode;
  }
}

/**
 * Try to extract encoded data from a comment using all templates
 */
function tryExtractEncodedData(commentText: string): string | null {
  for (const template of COMMENT_TEMPLATES) {
    if (commentText.startsWith(template.before) && commentText.endsWith(template.after)) {
      // Extract the middle part
      const middle = commentText.substring(
        template.before.length, 
        commentText.length - template.after.length
      );
      
      // Keep only valid Base64 characters
      return middle.split('').filter(c => BASE64_CHARS.includes(c)).join('');
    }
  }
  
  // Look for high entropy sections in the comment
  // This is a fallback method
  const words = commentText.split(/\s+/);
  for (const word of words) {
    if (word.length >= 8) {
      const entropy = calculateEntropy(word);
      if (entropy * word.length > MIN_ENTROPY_BITS) {
        // This word has high entropy, might be our encoded data
        return word.split('').filter(c => BASE64_CHARS.includes(c)).join('');
      }
    }
  }
  
  return null;
}

/**
 * Reveal a hidden message from source code
 */
export function revealFromCode(
  encodedCode: string,
  password: string = ''
): string {
  // Find all comments in the code
  const comments = findComments(encodedCode);
  
  if (comments.length === 0) {
    throw new Error('No comments found in the code to check for hidden messages.');
  }
  
  // Try to extract encoded data from each comment
  for (const comment of comments) {
    const encodedData = tryExtractEncodedData(comment.content);
    
    if (encodedData) {
      try {
        // Decode from Base64 to binary
        const binaryMessage = decodeFromBase64(encodedData);
        
        // Convert binary back to text
        let message = binaryToText(binaryMessage.substring(0, Math.floor(binaryMessage.length / 8) * 8));
        
        // Decrypt if password provided
        if (password) {
          message = decryptMessage(message, password);
        }
        
        // Check if the message makes sense (has printable characters)
        if (message.length > 0 && /^[\x20-\x7E]+$/.test(message)) {
          return message;
        }
      } catch (e) {
        // If decoding fails, continue to the next comment
        continue;
      }
    }
  }
  
  throw new Error('No hidden message found in the code comments.');
}

/**
 * Check if code might contain a hidden message
 * This is just a heuristic - we look for comments with higher-than-normal entropy
 */
export function mightContainHiddenMessage(code: string): boolean {
  const comments = findComments(code);
  
  for (const comment of comments) {
    // Calculate entropy of the comment content
    const entropy = calculateEntropy(comment.content);
    
    // Check if the entropy is suspiciously high
    // Typical English text has entropy around 4-5 bits per character
    if (entropy > 5.5) {
      return true;
    }
    
    // Also check for our templated comments
    for (const template of COMMENT_TEMPLATES) {
      if (comment.content.startsWith(template.before) && 
          comment.content.endsWith(template.after)) {
        return true;
      }
    }
  }
  
  return false;
}